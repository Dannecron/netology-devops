Выполнение [домашнего задания](https://github.com/netology-code/virt-homeworks/blob/virt-11/05-virt-03-docker/README.md) 
по теме "5.3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"".

## Q/A

### Задача 1

> Сценарий выполения задачи:

> - создайте свой репозиторий на https://hub.docker.com;
> - выберете любой образ, который содержит веб-сервер Nginx;
> - создайте свой fork образа;
> - реализуйте функциональность:
> запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
> ```html
> <html>
> <head>
> Hey, Netology
> </head>
> <body>
> <h1>I’m DevOps Engineer!</h1>
> </body>
> </html>
> ```
> Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.

Репозиторий с образом: [https://hub.docker.com/r/dannecron/netology-devops-nginx](https://hub.docker.com/r/dannecron/netology-devops-nginx)

За основу был взят [официальный образ nginx](https://hub.docker.com/_/nginx). Для решения задачи был сформирован [Dockerfile](./nginx/Dockerfile),
а также конфигурация [site.conf](./nginx/site.conf) и [index.html](./nginx/index.html).

Для сборки образа используем команду из директории [nginx](./nginx):

```shell
docker build -t dannecron/netology-devops-nginx:latest .
[+] Building 6.6s (9/9) FINISHED
```

Проверим, что всё работает. Для этого запустим контейнер из только что созданного образа и сделаем curl-запрос:

```shell
docker run --rm -it -p 18800:80 dannecron/netology-devops-nginx:latest

curl http://localhost:18800
<html>
  <head>
    Hey, Netology
  </head>
  <body>
    <h1>I`m DevOps Engineer!</h1>
  </body>
</html>
```

После этого опубликуем образ:

```shell
docker push dannecron/netology-devops-nginx:latest
```

### Задача 2

> Посмотрите на сценарий ниже и ответьте на вопрос:
> "Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"
> 
> Детально опишите и обоснуйте свой выбор.
> --
>
> Сценарий:
> 
> - Высоконагруженное монолитное java веб-приложение;
> - Nodejs веб-приложение;
> - Мобильное приложение c версиями для Android и iOS;
> - Шина данных на базе Apache Kafka;
> - Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
> - Мониторинг-стек на базе Prometheus и Grafana;
> - MongoDB, как основное хранилище данных для java-приложения;
> - Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

* Высоконагруженное монолитное java веб-приложение

В данном случае `docker` будет оптимальным решением, так как не будет требовать каких-то дополнительных настроек JVM, а для запуска достаточно будет установленного docker.
В процессе упаковки приложения в образ можно произвести оптимизацию, которая уменьшит размер финального образа,
что минимизирует растраты на трафик при деплое и растраты на хранение в registry.
Ещё одним плюсом является возможность горизонтального масштабирования приложения без дополнительных настроек самого приложения.

* Nodejs веб-приложение

Аналогично, как и для java веб-приложения, docker будет оптимальным решением. Плюсы подхода сохраняются.

* Мобильное приложение c версиями для Android и iOS

Само мобильное приложение необходимо запускать только на физическом устройстве, так как мобильные устройства не поддерживают
использование `docker` или виртуализацию.

* Шина данных на базе Apache Kafka

Шина данных на базе Apache Kafka - это кластерное решение, состоящее как минимум из двух сервисов
и очень сильно зависящее от доступности сети. 
В таком случае будет наиболее оптимально запускать сервисы в виртуальных машинах, чтобы была возможность
более гибко конфигурировать локальную сеть для данного кластера, при этом увеличив стабильность работы.

* Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana

todo ???

* Мониторинг-стек на базе Prometheus и Grafana

Так как Prometheus - это база данных, то оптимально будет выбрать решение на базе физической машины,
чтобы увеличить отказоустойчивость. 

* MongoDB, как основное хранилище данных для java-приложения

todo ???

* Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry

todo ???

### Задача 3

> - Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
> - Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
> - Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;
> - Добавьте еще один файл в папку ```/data``` на хостовой машине;
> - Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

todo ???