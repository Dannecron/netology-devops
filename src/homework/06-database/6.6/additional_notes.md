Дополнительные комментарии по домашнему заданию:

### Задача 2

[задача](./readme.md#задача-2)

> Проблема скорей всего в том что вся память занята истекшими в один и тот же момент ключами которые еще не удаленны.
> Так как Redis использует в основном однопоточную конструкцию, поэтому все запросы обслуживаются последовательно, в связи с этим пока не выполнится очистка, все операции записи блокируются.

### Задача 4

[задача](./readme.md#задача-4)

> Можно поиграть с параметрами, которые регулируют память в Postgres из основных это: `max_connections`, `shared_buffer`, `work_mem`, `effective_cache_size`, `maintenance_work_mem`.
>
> `shared_buffer` - этот параметр устанавливает, сколько выделенной памяти будет использоваться PostgreSQL для кеширования.
>
> `wal_buffers` - PostgreSQL сначала записывает записи в WAL (журнал пред записи) в буферы, а затем эти буферы сбрасываются на диск. Размер буфера по умолчанию, определенный `wal_buffers`, составляет 16 МБ. Но если у нас много одновременных подключений, то более высокое значение может повысить производительность.
>
> `effective_cache_size` - предоставляет оценку памяти, доступной для кэширования диска. Это всего лишь ориентир, а не точный объем выделенной памяти или кеша. Он не выделяет фактическую память, но сообщает оптимизатору объем кеша, доступный в ядре. Если значение этого параметра установлено слишком низким, планировщик запросов может принять решение не использовать некоторые индексы, даже если они будут полезны. Поэтому установка большого значения всегда имеет смысл.
>
> `work_mem` - если нам нужно выполнить сложную сортировку, увеличьте значение `work_mem` для получения хороших результатов. Сортировка в памяти происходит намного быстрее, чем сортировка данных на диске. Установка очень высокого значения может стать причиной узкого места в памяти для нашей среды, поскольку этот параметр относится к операции сортировки пользователя.
>
> `maintenance_work_mem` - это параметр памяти, используемый для задач обслуживания.
