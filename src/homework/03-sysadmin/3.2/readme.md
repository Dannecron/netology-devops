Выполнение [домашнего задания](https://github.com/netology-code/sysadm-homeworks/blob/devsys10/03-sysadmin-02-terminal/README.md) 
по теме "Работа в терминале, лекция 2".

## Q/A

1. Какого типа команда `cd`?

При вызове `type cd` будет выведено, что `cd is a shell builtin`, то есть команда встроенная в оболочку. 
Данная команда необходима для работы пользователя с терминалом и для работы других команд, именно поэтому она встроена в ядро операционной системы.

2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?

Альтернативой является команда `grep -c <some_string> <some_file>`.

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Найти родителя всех процессов можно вызвав команду `pstree -p | grep \(1\)`. 
Ответ: процесс с PID 1 - `systemd`. 

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

Откроем два терминала на виртуальной машине. Для каждого из них будет создан новый файл в директории `/dev/pts/`.
Таким образом, если мы хотим перенаправить stderr команды, то нужно выполнить следующие действия:
перенаправить вывод stderr в stdout, затем перенаправить stdout в `/dev/pts/<n>`, где <n> - целое число, идентификатор сессии терминала. 
Полный пример команды:

```shell
ls /some/invalid/dir 2>&1 1>&/dev/pts/<n>
```

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл?

Да, подобное можно реализовать следующим способом.

```shell
touch in_file
echo "abc" > in_file
echo "bcd" >> in_file
grep abc < in_file 1>&out_file
cat out_file
```

Содержимое out_file является выводом команды grep, а именно одна строка `abc`.

6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Да, подобное возможно. Достаточно, например, открыть новую сессию терминала в графической оболочке и выполнить перенаправление потока в `/dev/pts/<n>`.
Так же любая программа с графическим интерфейсом может выполнить данное действие. Наблюдать данные возможно,
если открыт терминал, подключённый к конкретной сессии.

7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

Насколько я понимаю, команда `bash 5>&1` создаёт новую терминальную сессию с перенаправлением потока из `5` в `1`, то есть в `stdout`.
Но так как `5` - это не стандартный идентификатор потока, поэтому оболочка создаст новый файл `/proc/$$/fd/5`.
Данный файл будет алиасом для stdout, поэтому выполнение `echo` выведет содержимое в терминал,
как это сделал бы обычный вызов команды без перенаправлений потока.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?

Да, такая возможность есть. Сначала необходимо запустить терминал с новым перенаправлением, как в предыдущем вопросе: `bash 5>&1`.
Затем уже можно выполнить перенаправление потоков следующим образом:

```shell
ls -la /tmp/wrong_dir 2>&1 1>&5 | less
```

Таким образом в команду `less` попадёт следующий текст: `ls: cannot access '/tmp/wrong_dir': No such file or directory`.

9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

Данная команда выведет все переменные окружения, которые инициализированы в текущей сессии терминала.
Аналогичный результат может быть достигнут вызовом команд `printenv` или `env`.

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

Файл `/proc/<PID>/cmdline` - это файл, предназначенный только для чтения, который содержит в себе полную команду процесса, но только если процесс не зомби.
Файл `/proc/<PID>/exe` - это файл-символическая ссылка, содержащая актуальный полный путь до выполняемой команды.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`

Выполним команду `cat /proc/cpuinfo | grep sse`. В выводе можно найти такие версии, как `sse`, `sse2`, `ssse3`, `sse4_1`, `sse4_2`.
Таким образом, ответом на вопрос будет `sse4_2`.

12. Почему команда `ssh localhost 'tty'` внутри виртуальной машины выдаёт ошибку `not a tty`

Изначально, нужно понять, что происходит при выполнении исходной команды. Судя по мануалу команды `ssh`, 
`localhost` является пунктом назначения, куда будет произведено подключение, 
а `tty` - это команда, которая будет выполнена на удалённом сервере. Из того же мануала следует, 
что при указании команды будет произведено выполнение команды, а не логин пользователя. То есть, 
команда будет выполнена без выделения отдельной сессии для пользователя,
а значит команда `tty` в данном случае действительно не сможет найти запущенный экземпляр терминала.

Изменить поведение можно принудительно заставив `ssh` создать новую сессию, для этого нужно добавить ключ `-t`, 
то есть выполнить команду `ssh -t localhost 'tty'`.  

13. Необходимо переместить запущенный процесс из одной сессии в другую с использованием утилиты `reptyr`

На виртуальной машине утилита не установлена, поэтому установим её `sudo apt install reptyr`.
В качестве примера запустим утилиту `screen`, которая запустит новую сессию внутри себя.
В другом подключении через ssh к виртуальной машине запустим "долгий" процесс, например, `less .bash_history`.
Внутри сессии `screen` найдём PID процесса `less`, для этого выполним команду `lsof | grep less`.
Затем выполним команду `reptyr <PID>`.

К сожалению, полностью перенести процесс не получилось, есть какие-то странные ошибки по типу `Operation not permitted` 
или "зависания" второго терминала, если выполнить команду от администратора.

14. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

Команда `tee` читает стандартный поток ввода и пишет его в стандартный поток вывода и файлы.
В отличие от `echo` перенаправление идёт в рамках одного процесса, именно поэтому `sudo tee` будет работать,
так как процесс берёт стандартный поток ввода от текущего пользователя, затем начинает запись с повышенными привилегиями.